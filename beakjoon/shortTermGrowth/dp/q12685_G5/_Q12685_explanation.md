## 12685번: 평범한 배낭

### 1. 입력 예시

- N = 4, K = 7

- (Wi, Vi) = (6, 13), (4, 8), (3, 6), (5, 12)

### 2. 사용 알고리즘

- 다이나믹 프로그래밍

### 3. 데이터 표현

- dp[][]: 메모이제이션
- weights[i]: i번째 물건의 무게
- values[i]: i번째 물건의 가치

### 4. 풀이

- dp 메모이제이션 테이블

| i \ dp | 0 | 1 | 2 | 3 | 4 | 5  | 6  | 7  |
|:------:|:-:|:-:|:-:|:-:|:-:|:--:|:--:|:--:|
|   1    | 0 | 0 | 0 | 0 | 0 | 0  | 13 | 13 |
|   2    | 0 | 0 | 0 | 0 | 8 | 8  | 13 | 13 |
|   3    | 0 | 0 | 0 | 6 | 8 | 8  | 13 | 13 |
|   4    | 0 | 0 | 0 | 6 | 8 | 12 | 13 | 13 |

- 수도코드

```
if i = 0 or k = 0
-> dp[k][i] = dp[k][i-1]

else if weights[i] > k
-> dp[k][i] = dp[k][i - 1]

else if i > 0 and weights[i] <= k
-> dp[k][i] = max(dp[k][i - 1], dp[k - weights[i]][i - 1] + value[i])
```

### 5. 설명

dp[k]는 k무게만큼 수용 가능할 때 최대의 가치를 갖는 value를 저장한다는 의미

여기에 여러 물건을 조합해야하므로 물건의 순서를 의미하는 i 인덱스를 추가하여 2차원 배열로 메모이제이션

즉, dp[k][i]는 배낭이 k무게만큼 최대로 수용 가능 할 때, i 시점에서 최대의 가치의 합을 저장한다는 의미

따라서 위의 수도코드는 i번째 물건의 무게가 k보다 크다면, 기존 배낭에 담았던 물건 그대로(`dp[k][i - 1]`) 둔다는 의미

무게가 k보다 작은 물건이라면, `k - weights[i]` 무게 만큼 물건을 담았을 경우를 탐색하여(`dp[k - weights[i]]`)

이 때 이전에 저장했던 `i - 1` 시점의 물건 조합의 가치 합(`dp[k - weights[i]][i - 1]`) + 현재 물건의 가치 합(`values[i]`)과

기존 배낭에 담아 놓았던 물건의 가치합(`dp[k][i - 1]`) 중 더 큰 것을 선택하겠다는 의미

결국에는 최대 무게 k = 1 부터 k = `K` 까지 반복하면서 마지막 최대 무게 `K`일 때 최대의 가치합이 저장될 것이다.

### 6. 개선된 알고리즘

i 번째 물건에 대해 가용한 최대 무게를 k = `K`부터 하나씩 줄여가면서 최대 가치를 갱신해가며 dp[k]에 저장한다.

이 때, 설정한 최대 무게 k가 물건의 무게보다 클 경우(`k >= weights[i]`)에만 탐색을 진행하여 연산 량을 줄인다.

또한, 이렇게 탐색을 하게되면, 각 무게별 가치합(`dp[k]`)안에 무조건 최선의 값이 들어가게 된다.

따라서 각 시점별(조합별) 가치 합을 저장할 필요가 없어지므로 메모이제이션을 1차원 배열만으로도 가능하다.