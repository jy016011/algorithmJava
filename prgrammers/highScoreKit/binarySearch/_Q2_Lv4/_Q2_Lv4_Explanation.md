## 프로그래머스 징검다리 문제 풀이

### 1. 문제 설명

제거해야하는 돌의 갯수 `n`, 돌들의 위치 정보 배열 `rocks`, 도착지점의 거리 `distance`가 주어졌을 때,

`n`개의 돌을 제거하여 구할 수 있는 돌들 간의 최소 거리 중 최대로 가질 수 있는 값을 구해야한다.

예를 들어, `n = 2`, `rocks = [2, 11, 14, 17, 21]`, `distance = 25` 일때

`2`, `21`을 제거하였을 때는 최소 간격이 `3`,

`17`, `21`을 제거하였을 때는 최소 간격이 `2`,

...

`2`, `14`를 제거하였을 때는 최소 간격이 `4` 이다.

따라서 답은 최댓값인 `4`가 된다.

### 2. 풀이

#### 알고리즘 선택

문제를 보았을 때는 브루트포스로 풀어야하나 싶지만, 바위의 갯수는 최대 5만개로 완탐으로 하기에는 시간이 모자르다.

시간을 줄이기 위해 다른 방법을 생각해 볼 수 있는데,

바로 돌 사이의 최소 거리를 임의로 잡아 제거할 돌들의 갯수를 구하고,

이 돌을 제거한 갯수와 `n`을 비교하여 탐색 범위를 다시 찾는 이진탐색으로 풀이할 수 있다.

처음의 `lowerBound`는 `1`로 주고, `upperBound`는 `distance`로 설정,

이 두 값의 중간값인 `mid`를 임의로 제거한 돌들 간격의 최소거리로 가정하여 이진탐색을 진행한다.

#### 문제 풀이

그렇다민 이제, 이 `mid`값을 이용하여 돌들을 제거하는 방식을 생각해보자.

위에서 `mid`를 설명할 때 `임의로 돌을 제거한 돌들 간격의 최소거리`라고 가정을 하였었다.

즉, 이 `mid`값을 가지고 있는 탐색 시점에서는 이 `mid`값보다 작은 돌 간격의 값이 있어서는 안된다는 것이다.

이는 즉, 돌 사이 간격을 따로 배열로 저장하여, 이를 `mid`값과 비교해 그보다 작다면 해당하는 돌을 제거하고 갯수를 세고,

아니라면 돌을 세지 않으면 된다는 것이다.

또한, 여기서 주의할 점으로는 돌을 제거하게 된다면, 자연스레 다음 돌과 이전에 제거하지 않았던 돌(혹은 시작지점)사이의 간격은

현재 제거한 돌의 간격만큼 늘어날 것이다. 따라서 매번 돌을 제거할 때마다 그 간격의 값을 어떤 한 변수에 더해주어 저장하고,

그 변수를 `mid`값과 비교하여 작으면 돌을 제거하고 갯수를 세고, `mid`값 이상이라면 그 변수의 값을 다시 0으로 설정해주어야 한다.
(이는 제거하지 않은 돌을 시작지점으로 다시 잡는 것을 의미한다.)

모든 돌들의 간격들을 순회하며 제거해 나갈 돌들을 다 세었다면, 이제 그 제거한 갯수를 `n`과 비교하여 이진탐색 범위를 설정한다.

일단 당연하게도 제거한 갯수가 `n`보다 크다면, 현재 최소 간격으로 잡은 `mid`가 예상보다 크다는 것이다.
(돌을 더 많이 제거할수록 최소간격도 그만큼 커질 수밖에 없으므로)

따라서 `제거한 갯수 > n`의 경우에는 `upperBound = mid - 1`로 주어 `mid`값을 줄이는 방향으로 이진탐색 범위를 재설정한다.

이제 다음 경우가 중요한데, 바로 제거한 갯수와 `n`이 같을 때와 제거한 갯수가 더 작을 때의 경우를 같이 묶어서 고려해야한다는 점이다.

일단 `제거한 갯수 < n`의 경우를 보면, 제거한 돌의 갯수가 작을수록 돌 사이 간격도 더 작다고 볼 수 있으므로

`mid`값을 증가시킬 필요가 있다. 따라서 `lowerBound = mid + 1`로 주어 이진탐색 범위를 재설정한다.

그렇다면 이제 `제거한 갯수 == n`의 경우인데, 이 경우에도 마찬가지라고 보면 된다.

왜냐하면, 처음 예제 설명에서 볼 수 있듯 임의의 `n`에 대해 돌들의 최소간격의 값이 여러개이다.

즉, 현재 `mid`값에서 `제거한 갯수 == n`이 더라도

이 `mid`값이 `n`개만큼 돌을 제거하였을 때 가질 수 있는 돌 사이 최소 간격이 최대값임을 보장할 수는 없다는 것이다.

따라서 이 경우에도 `mid`값을 더 크게하여 이진탐색을 진행햐여야 한다.

이렇게 탐색하다보면 더 이상 갯수 `n`을 만족하는 `mid`값이 없다면 다시 원래로 돌아와 아까 같을 때 저장한 `mid`값이 결국 답이 되거나,

더 큰 값이 발견되면 그것이 답으로 갱신되어

결국 마지막에 `제거한 갯수 == n`을 만족하는 mid값이 정답이 될 것이다.

### 3. 느낀점

알고보면 간단하나, 생각을 많이 요구하는 문제였다.

나도 완전한 풀이까지는 접근하지는 못하여서(돌을 제거하는 부분에서 헷갈렸다.)

다른 분들의 설명들을 보고 이해를 할 수 있었다.

하지만, 돌을 제거하고 그것을 세는 과정이 쉽게 이해가 되지않았다.

예를 들어 `[2, 11, 14, 17, 21]`과 최초 `lower = 1, upper = 25, mid = 13`으로 했을 때

`2`의 돌만 지우면 될것을 왜 `11`위치의 돌까지 지우는지 이해가 안됐었다.

왜냐하면, 돌의 최소 간격인 `mid`를 13으로 주었으니, 모든 돌 사이의 간격이 13이상이 되서는 안된다고 생각했었기 때문이다.

결국 많은 생각 끝에 `mid`값 이상의 간격들을 만들도록 돌을 제거한다는 관점으로 생각하니 이해할 수 있었다.

다른 분들도 나와 같은 어려움이 있을 것 같아, 내가 헷갈리고 이해가 잘 안갔던 부분들 위주로 설명해드리고 싶어서 풀이를 올린다.